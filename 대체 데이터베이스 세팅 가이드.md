# 대체 데이터베이스 세팅 가이드

> CV Monitor Dashboard를 MongoDB 또는 DynamoDB로 전환하는 방법

## 목차
- [Part 1: MongoDB 세팅](#part-1-mongodb-세팅)
- [Part 2: DynamoDB 세팅](#part-2-dynamodb-세팅)
- [Part 3: 전역 변경 사항 체크리스트](#part-3-전역-변경-사항-체크리스트)

---

# Part 1: MongoDB 세팅

## 1.1 MongoDB Atlas 설정

### 클러스터 생성
1. [https://cloud.mongodb.com](https://cloud.mongodb.com) 접속
2. **Build a Cluster** 클릭
3. 설정:
   - **Cloud Provider**: AWS
   - **Region**: `ap-northeast-2` (Seoul)
   - **Tier**: M0 (Free) 또는 M10+
4. **Create Cluster** 클릭

### 데이터베이스 사용자 생성
1. **Database Access** → **Add New Database User**
2. 인증 방식: Password
3. 권한: `readWriteAnyDatabase`

### 네트워크 접근 설정
1. **Network Access** → **Add IP Address**
2. 개발용: `0.0.0.0/0` (모든 IP 허용)
3. 프로덕션: 특정 IP만 허용

### 연결 문자열 확인
1. **Clusters** → **Connect** → **Connect your application**
2. 연결 문자열 복사:
```
mongodb+srv://<username>:<password>@cluster0.xxxxx.mongodb.net/<database>?retryWrites=true&w=majority
```

---

## 1.2 의존성 설치

```bash
# MongoDB 드라이버 및 ODM
pnpm add mongodb mongoose

# 타입 지원
pnpm add -D @types/mongoose
```

---

## 1.3 환경변수 설정

```bash
# .env.local

# MongoDB 연결
MONGODB_URI=mongodb+srv://username:password@cluster0.xxxxx.mongodb.net/cv-monitor?retryWrites=true&w=majority

# 데이터베이스 이름
MONGODB_DB_NAME=cv-monitor

# 기존 Supabase 설정은 주석 처리
# NEXT_PUBLIC_SUPABASE_URL=...
# NEXT_PUBLIC_SUPABASE_ANON_KEY=...
# SUPABASE_SERVICE_ROLE_KEY=...
```

---

## 1.4 MongoDB 연결 클라이언트

### lib/mongodb.ts (신규 생성)

```typescript
import { MongoClient, Db } from "mongodb"

const MONGODB_URI = process.env.MONGODB_URI!
const MONGODB_DB_NAME = process.env.MONGODB_DB_NAME || "cv-monitor"

if (!MONGODB_URI) {
  throw new Error("MONGODB_URI 환경변수가 설정되지 않았습니다")
}

interface MongoConnection {
  client: MongoClient
  db: Db
}

let cached: MongoConnection | null = null

export async function connectToDatabase(): Promise<MongoConnection> {
  if (cached) {
    return cached
  }

  const client = await MongoClient.connect(MONGODB_URI, {
    maxPoolSize: 10,
    serverSelectionTimeoutMS: 5000,
    socketTimeoutMS: 45000,
  })

  const db = client.db(MONGODB_DB_NAME)

  cached = { client, db }
  return cached
}

// 컬렉션 헬퍼
export async function getCollection<T extends Document>(name: string) {
  const { db } = await connectToDatabase()
  return db.collection<T>(name)
}

// DB 설정 여부 확인
export const isMongoDBConfigured = Boolean(MONGODB_URI)
export const useLocalDB = process.env.USE_MOCK_DATA === "true" || !isMongoDBConfigured
```

---

## 1.5 스키마 정의 (Mongoose)

### lib/models/index.ts (신규 생성)

```typescript
import mongoose, { Schema, Document } from "mongoose"

// ============================================================
// Category 스키마
// ============================================================
export interface ICategory extends Document {
  _id: string
  name: string
  color: string
  created_at: Date
}

const CategorySchema = new Schema<ICategory>({
  name: { type: String, required: true },
  color: { type: String, default: "#4ECDC4" },
  created_at: { type: Date, default: Date.now },
})

// ============================================================
// Item 스키마
// ============================================================
export interface IItem extends Document {
  _id: string
  category_id: string | null
  url: string
  platform: string
  product_name: string
  product_image: string | null
  price: number | null
  last_crawled_at: Date | null
  created_at: Date
}

const ItemSchema = new Schema<IItem>({
  category_id: { type: Schema.Types.ObjectId, ref: "Category", default: null },
  url: { type: String, required: true, unique: true },
  platform: { type: String, required: true },
  product_name: { type: String, required: true },
  product_image: { type: String, default: null },
  price: { type: Number, default: null },
  last_crawled_at: { type: Date, default: null },
  created_at: { type: Date, default: Date.now },
})

// ============================================================
// Review 스키마
// ============================================================
export interface IReview extends Document {
  _id: string
  item_id: string
  author: string
  rating: number
  content: string
  images: string[]
  date: Date | null
  sentiment: "positive" | "negative" | "neutral" | null
  keywords: string[]
  crawled_at: Date
}

const ReviewSchema = new Schema<IReview>({
  item_id: { type: Schema.Types.ObjectId, ref: "Item", required: true },
  author: { type: String, default: "Unknown" },
  rating: { type: Number, min: 1, max: 5 },
  content: { type: String },
  images: [{ type: String }],
  date: { type: Date, default: null },
  sentiment: { type: String, enum: ["positive", "negative", "neutral", null] },
  keywords: [{ type: String }],
  crawled_at: { type: Date, default: Date.now },
})

// 중복 방지 복합 인덱스
ReviewSchema.index({ item_id: 1, author: 1, date: 1, content: 1 }, { unique: true })

// ============================================================
// Review Analysis 스키마
// ============================================================
export interface IReviewAnalysis extends Document {
  _id: string
  item_id: string
  analysis_type: string
  result: Record<string, unknown>
  created_at: Date
}

const ReviewAnalysisSchema = new Schema<IReviewAnalysis>({
  item_id: { type: Schema.Types.ObjectId, ref: "Item" },
  analysis_type: { type: String, required: true },
  result: { type: Schema.Types.Mixed, required: true },
  created_at: { type: Date, default: Date.now },
})

ReviewAnalysisSchema.index({ item_id: 1, analysis_type: 1 }, { unique: true })

// ============================================================
// 모델 export
// ============================================================
export const Category = mongoose.models.Category || mongoose.model<ICategory>("Category", CategorySchema)
export const Item = mongoose.models.Item || mongoose.model<IItem>("Item", ItemSchema)
export const Review = mongoose.models.Review || mongoose.model<IReview>("Review", ReviewSchema)
export const ReviewAnalysis = mongoose.models.ReviewAnalysis || mongoose.model<IReviewAnalysis>("ReviewAnalysis", ReviewAnalysisSchema)
```

---

## 1.6 MongoDB용 DB 레이어

### lib/mongo-db.ts (신규 생성)

```typescript
import { connectToDatabase } from "./mongodb"
import { ObjectId } from "mongodb"

// ============================================================
// Categories CRUD
// ============================================================
export const mongoCategories = {
  async getAll() {
    const { db } = await connectToDatabase()
    return db.collection("categories").find().toArray()
  },

  async getById(id: string) {
    const { db } = await connectToDatabase()
    return db.collection("categories").findOne({ _id: new ObjectId(id) })
  },

  async create(data: { name: string; color?: string }) {
    const { db } = await connectToDatabase()
    const result = await db.collection("categories").insertOne({
      name: data.name,
      color: data.color || "#4ECDC4",
      created_at: new Date(),
    })
    return { id: result.insertedId.toString(), ...data }
  },

  async update(id: string, data: Partial<{ name: string; color: string }>) {
    const { db } = await connectToDatabase()
    await db.collection("categories").updateOne(
      { _id: new ObjectId(id) },
      { $set: data }
    )
    return this.getById(id)
  },

  async delete(id: string) {
    const { db } = await connectToDatabase()
    // 연관된 items의 category_id null 처리
    await db.collection("items").updateMany(
      { category_id: new ObjectId(id) },
      { $set: { category_id: null } }
    )
    const result = await db.collection("categories").deleteOne({ _id: new ObjectId(id) })
    return result.deletedCount > 0
  },
}

// ============================================================
// Items CRUD
// ============================================================
export const mongoItems = {
  async getAll() {
    const { db } = await connectToDatabase()

    // Aggregation으로 카테고리 조인 + 리뷰 통계
    return db.collection("items").aggregate([
      {
        $lookup: {
          from: "categories",
          localField: "category_id",
          foreignField: "_id",
          as: "categories",
        },
      },
      { $unwind: { path: "$categories", preserveNullAndEmptyArrays: true } },
      {
        $lookup: {
          from: "reviews",
          localField: "_id",
          foreignField: "item_id",
          as: "reviews",
        },
      },
      {
        $addFields: {
          id: { $toString: "$_id" },
          review_count: { $size: "$reviews" },
          avg_rating: { $avg: "$reviews.rating" },
        },
      },
      { $project: { reviews: 0 } },
    ]).toArray()
  },

  async getById(id: string) {
    const { db } = await connectToDatabase()
    return db.collection("items").findOne({ _id: new ObjectId(id) })
  },

  async create(data: {
    url: string
    platform: string
    category_id?: string
    product_name?: string
    product_image?: string
    price?: number
  }) {
    const { db } = await connectToDatabase()
    const result = await db.collection("items").insertOne({
      category_id: data.category_id ? new ObjectId(data.category_id) : null,
      url: data.url,
      platform: data.platform,
      product_name: data.product_name || null,
      product_image: data.product_image || null,
      price: data.price || null,
      last_crawled_at: null,
      created_at: new Date(),
    })
    return { id: result.insertedId.toString(), ...data }
  },

  async delete(id: string) {
    const { db } = await connectToDatabase()
    // 연관된 리뷰 삭제
    await db.collection("reviews").deleteMany({ item_id: new ObjectId(id) })
    const result = await db.collection("items").deleteOne({ _id: new ObjectId(id) })
    return result.deletedCount > 0
  },

  async updateLastCrawled(id: string) {
    const { db } = await connectToDatabase()
    await db.collection("items").updateOne(
      { _id: new ObjectId(id) },
      { $set: { last_crawled_at: new Date() } }
    )
  },
}

// ============================================================
// Reviews CRUD
// ============================================================
export const mongoReviews = {
  async getAll(filters?: {
    itemId?: string
    sentiment?: string
    startDate?: string
    endDate?: string
  }) {
    const { db } = await connectToDatabase()

    const query: Record<string, unknown> = {}
    if (filters?.itemId) query.item_id = new ObjectId(filters.itemId)
    if (filters?.sentiment) query.sentiment = filters.sentiment
    if (filters?.startDate || filters?.endDate) {
      query.date = {}
      if (filters?.startDate) (query.date as Record<string, Date>).$gte = new Date(filters.startDate)
      if (filters?.endDate) (query.date as Record<string, Date>).$lte = new Date(filters.endDate)
    }

    return db.collection("reviews").aggregate([
      { $match: query },
      {
        $lookup: {
          from: "items",
          localField: "item_id",
          foreignField: "_id",
          as: "items",
        },
      },
      { $unwind: { path: "$items", preserveNullAndEmptyArrays: true } },
      {
        $addFields: {
          id: { $toString: "$_id" },
          item_id: { $toString: "$item_id" },
        },
      },
      { $sort: { date: -1 } },
    ]).toArray()
  },

  async bulkUpsert(itemId: string, reviews: Array<{
    author: string
    rating?: number
    content: string
    images?: string[]
    date?: string
  }>) {
    const { db } = await connectToDatabase()
    let inserted = 0
    let skipped = 0

    for (const review of reviews) {
      try {
        await db.collection("reviews").insertOne({
          item_id: new ObjectId(itemId),
          author: review.author || "Unknown",
          rating: review.rating || 5,
          content: review.content,
          images: review.images || [],
          date: review.date ? new Date(review.date) : null,
          sentiment: null,
          keywords: [],
          crawled_at: new Date(),
        })
        inserted++
      } catch (error: unknown) {
        // 중복 키 에러 (11000)
        if ((error as { code?: number }).code === 11000) {
          skipped++
        } else {
          throw error
        }
      }
    }

    return { inserted, skipped }
  },

  async getStats(itemId?: string) {
    const { db } = await connectToDatabase()
    const match = itemId ? { item_id: new ObjectId(itemId) } : {}

    const stats = await db.collection("reviews").aggregate([
      { $match: match },
      {
        $group: {
          _id: null,
          total: { $sum: 1 },
          avgRating: { $avg: "$rating" },
          positive: {
            $sum: { $cond: [{ $eq: ["$sentiment", "positive"] }, 1, 0] },
          },
          negative: {
            $sum: { $cond: [{ $eq: ["$sentiment", "negative"] }, 1, 0] },
          },
          neutral: {
            $sum: { $cond: [{ $eq: ["$sentiment", "neutral"] }, 1, 0] },
          },
        },
      },
    ]).toArray()

    return stats[0] || { total: 0, positive: 0, negative: 0, neutral: 0, avgRating: 0 }
  },

  async bulkUpdateAnalysis(updates: Array<{
    id: string
    sentiment: "positive" | "negative" | "neutral"
    keywords: string[]
  }>) {
    const { db } = await connectToDatabase()
    const bulkOps = updates.map((u) => ({
      updateOne: {
        filter: { _id: new ObjectId(u.id) },
        update: { $set: { sentiment: u.sentiment, keywords: u.keywords } },
      },
    }))

    const result = await db.collection("reviews").bulkWrite(bulkOps)
    return result.modifiedCount
  },

  async getKeywordStats(itemIds?: string[]) {
    const { db } = await connectToDatabase()

    const match: Record<string, unknown> = { keywords: { $ne: [] } }
    if (itemIds?.length) {
      match.item_id = { $in: itemIds.map((id) => new ObjectId(id)) }
    }

    const result = await db.collection("reviews").aggregate([
      { $match: match },
      { $unwind: "$keywords" },
      {
        $group: {
          _id: { keyword: "$keywords", sentiment: "$sentiment" },
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
    ]).toArray()

    const positive: { word: string; count: number }[] = []
    const negative: { word: string; count: number }[] = []

    result.forEach((r) => {
      if (r._id.sentiment === "positive") {
        positive.push({ word: r._id.keyword, count: r.count })
      } else if (r._id.sentiment === "negative") {
        negative.push({ word: r._id.keyword, count: r.count })
      }
    })

    return { positive, negative }
  },
}

// ============================================================
// Export
// ============================================================
export const mongoDB = {
  categories: mongoCategories,
  items: mongoItems,
  reviews: mongoReviews,
}
```

---

# Part 2: DynamoDB 세팅

## 2.1 AWS 설정

### IAM 사용자 생성
1. AWS Console → IAM → Users → **Add users**
2. 사용자 이름: `cv-monitor-dynamodb`
3. **Attach policies directly**:
   - `AmazonDynamoDBFullAccess`
4. Access Key 생성 및 저장

### DynamoDB 테이블 생성

AWS Console → DynamoDB → **Create table**

#### 테이블 1: Categories
- **Table name**: `cv-monitor-categories`
- **Partition key**: `id` (String)
- **Settings**: Default

#### 테이블 2: Items
- **Table name**: `cv-monitor-items`
- **Partition key**: `id` (String)
- **GSI (Global Secondary Index)**:
  - `category_id-index`: Partition key = `category_id`
  - `platform-index`: Partition key = `platform`

#### 테이블 3: Reviews
- **Table name**: `cv-monitor-reviews`
- **Partition key**: `id` (String)
- **GSI**:
  - `item_id-index`: Partition key = `item_id`, Sort key = `date`
  - `sentiment-index`: Partition key = `sentiment`

#### 테이블 4: ReviewAnalysis
- **Table name**: `cv-monitor-analysis`
- **Partition key**: `item_id` (String)
- **Sort key**: `analysis_type` (String)

---

## 2.2 의존성 설치

```bash
# AWS SDK v3
pnpm add @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb @aws-sdk/util-dynamodb
```

---

## 2.3 환경변수 설정

```bash
# .env.local

# AWS 자격 증명
AWS_ACCESS_KEY_ID=AKIAXXXXXXXXXXXXXXXX
AWS_SECRET_ACCESS_KEY=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
AWS_REGION=ap-northeast-2

# DynamoDB 테이블 이름 (선택 - 기본값 사용 가능)
DYNAMODB_TABLE_PREFIX=cv-monitor

# 기존 Supabase 설정은 주석 처리
# NEXT_PUBLIC_SUPABASE_URL=...
```

---

## 2.4 DynamoDB 클라이언트

### lib/dynamodb.ts (신규 생성)

```typescript
import { DynamoDBClient } from "@aws-sdk/client-dynamodb"
import {
  DynamoDBDocumentClient,
  GetCommand,
  PutCommand,
  DeleteCommand,
  QueryCommand,
  ScanCommand,
  UpdateCommand,
  BatchWriteCommand,
} from "@aws-sdk/lib-dynamodb"

// DynamoDB 클라이언트 초기화
const client = new DynamoDBClient({
  region: process.env.AWS_REGION || "ap-northeast-2",
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
  },
})

// Document Client (JavaScript 객체로 작업 가능)
export const dynamoDB = DynamoDBDocumentClient.from(client, {
  marshallOptions: {
    removeUndefinedValues: true,
    convertEmptyValues: true,
  },
})

// 테이블 이름
const PREFIX = process.env.DYNAMODB_TABLE_PREFIX || "cv-monitor"
export const TABLES = {
  CATEGORIES: `${PREFIX}-categories`,
  ITEMS: `${PREFIX}-items`,
  REVIEWS: `${PREFIX}-reviews`,
  ANALYSIS: `${PREFIX}-analysis`,
}

// DB 설정 여부
export const isDynamoDBConfigured = Boolean(
  process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY
)
export const useLocalDB = process.env.USE_MOCK_DATA === "true" || !isDynamoDBConfigured

// Export commands for use
export {
  GetCommand,
  PutCommand,
  DeleteCommand,
  QueryCommand,
  ScanCommand,
  UpdateCommand,
  BatchWriteCommand,
}
```

---

## 2.5 DynamoDB용 DB 레이어

### lib/dynamo-db.ts (신규 생성)

```typescript
import { v4 as uuidv4 } from "uuid"
import {
  dynamoDB,
  TABLES,
  GetCommand,
  PutCommand,
  DeleteCommand,
  QueryCommand,
  ScanCommand,
  UpdateCommand,
  BatchWriteCommand,
} from "./dynamodb"

// ============================================================
// Categories CRUD
// ============================================================
export const dynamoCategories = {
  async getAll() {
    const result = await dynamoDB.send(
      new ScanCommand({ TableName: TABLES.CATEGORIES })
    )
    return result.Items || []
  },

  async getById(id: string) {
    const result = await dynamoDB.send(
      new GetCommand({
        TableName: TABLES.CATEGORIES,
        Key: { id },
      })
    )
    return result.Item || null
  },

  async create(data: { name: string; color?: string }) {
    const item = {
      id: uuidv4(),
      name: data.name,
      color: data.color || "#4ECDC4",
      created_at: new Date().toISOString(),
    }

    await dynamoDB.send(
      new PutCommand({
        TableName: TABLES.CATEGORIES,
        Item: item,
      })
    )

    return item
  },

  async update(id: string, data: Partial<{ name: string; color: string }>) {
    const updateExpr: string[] = []
    const exprAttrValues: Record<string, string> = {}
    const exprAttrNames: Record<string, string> = {}

    if (data.name) {
      updateExpr.push("#name = :name")
      exprAttrNames["#name"] = "name"
      exprAttrValues[":name"] = data.name
    }
    if (data.color) {
      updateExpr.push("color = :color")
      exprAttrValues[":color"] = data.color
    }

    await dynamoDB.send(
      new UpdateCommand({
        TableName: TABLES.CATEGORIES,
        Key: { id },
        UpdateExpression: `SET ${updateExpr.join(", ")}`,
        ExpressionAttributeNames: Object.keys(exprAttrNames).length ? exprAttrNames : undefined,
        ExpressionAttributeValues: exprAttrValues,
      })
    )

    return this.getById(id)
  },

  async delete(id: string) {
    await dynamoDB.send(
      new DeleteCommand({
        TableName: TABLES.CATEGORIES,
        Key: { id },
      })
    )
    return true
  },
}

// ============================================================
// Items CRUD
// ============================================================
export const dynamoItems = {
  async getAll() {
    const result = await dynamoDB.send(
      new ScanCommand({ TableName: TABLES.ITEMS })
    )
    const items = result.Items || []

    // 각 아이템에 카테고리 정보와 리뷰 통계 추가
    const enrichedItems = await Promise.all(
      items.map(async (item) => {
        // 카테고리 조회
        let categories = null
        if (item.category_id) {
          categories = await dynamoCategories.getById(item.category_id)
        }

        // 리뷰 통계
        const stats = await dynamoReviews.getStats(item.id)

        return {
          ...item,
          categories,
          review_count: stats.total,
          avg_rating: stats.avgRating,
        }
      })
    )

    return enrichedItems
  },

  async getById(id: string) {
    const result = await dynamoDB.send(
      new GetCommand({
        TableName: TABLES.ITEMS,
        Key: { id },
      })
    )
    return result.Item || null
  },

  async create(data: {
    url: string
    platform: string
    category_id?: string
    product_name?: string
    product_image?: string
    price?: number
  }) {
    const item = {
      id: uuidv4(),
      category_id: data.category_id || null,
      url: data.url,
      platform: data.platform,
      product_name: data.product_name || null,
      product_image: data.product_image || null,
      price: data.price || null,
      last_crawled_at: null,
      created_at: new Date().toISOString(),
    }

    await dynamoDB.send(
      new PutCommand({
        TableName: TABLES.ITEMS,
        Item: item,
      })
    )

    return item
  },

  async delete(id: string) {
    // 연관 리뷰 삭제
    const reviews = await dynamoDB.send(
      new QueryCommand({
        TableName: TABLES.REVIEWS,
        IndexName: "item_id-index",
        KeyConditionExpression: "item_id = :itemId",
        ExpressionAttributeValues: { ":itemId": id },
      })
    )

    if (reviews.Items?.length) {
      const deleteRequests = reviews.Items.map((r) => ({
        DeleteRequest: { Key: { id: r.id } },
      }))

      // 25개씩 배치 삭제
      for (let i = 0; i < deleteRequests.length; i += 25) {
        await dynamoDB.send(
          new BatchWriteCommand({
            RequestItems: {
              [TABLES.REVIEWS]: deleteRequests.slice(i, i + 25),
            },
          })
        )
      }
    }

    await dynamoDB.send(
      new DeleteCommand({
        TableName: TABLES.ITEMS,
        Key: { id },
      })
    )

    return true
  },

  async updateLastCrawled(id: string) {
    await dynamoDB.send(
      new UpdateCommand({
        TableName: TABLES.ITEMS,
        Key: { id },
        UpdateExpression: "SET last_crawled_at = :now",
        ExpressionAttributeValues: { ":now": new Date().toISOString() },
      })
    )
  },
}

// ============================================================
// Reviews CRUD
// ============================================================
export const dynamoReviews = {
  async getAll(filters?: {
    itemId?: string
    sentiment?: string
  }) {
    let result

    if (filters?.itemId) {
      // GSI로 조회
      result = await dynamoDB.send(
        new QueryCommand({
          TableName: TABLES.REVIEWS,
          IndexName: "item_id-index",
          KeyConditionExpression: "item_id = :itemId",
          ExpressionAttributeValues: { ":itemId": filters.itemId },
          ScanIndexForward: false, // 날짜 내림차순
        })
      )
    } else if (filters?.sentiment) {
      result = await dynamoDB.send(
        new QueryCommand({
          TableName: TABLES.REVIEWS,
          IndexName: "sentiment-index",
          KeyConditionExpression: "sentiment = :sentiment",
          ExpressionAttributeValues: { ":sentiment": filters.sentiment },
        })
      )
    } else {
      result = await dynamoDB.send(
        new ScanCommand({ TableName: TABLES.REVIEWS })
      )
    }

    return result.Items || []
  },

  async bulkUpsert(itemId: string, reviews: Array<{
    author: string
    rating?: number
    content: string
    images?: string[]
    date?: string
  }>) {
    let inserted = 0
    let skipped = 0

    // DynamoDB는 조건부 Put으로 중복 체크
    for (const review of reviews) {
      const id = uuidv4()
      const uniqueKey = `${itemId}#${review.author}#${review.date}#${review.content?.slice(0, 50)}`

      try {
        await dynamoDB.send(
          new PutCommand({
            TableName: TABLES.REVIEWS,
            Item: {
              id,
              item_id: itemId,
              unique_key: uniqueKey,
              author: review.author || "Unknown",
              rating: review.rating || 5,
              content: review.content,
              images: review.images || [],
              date: review.date || null,
              sentiment: null,
              keywords: [],
              crawled_at: new Date().toISOString(),
            },
            ConditionExpression: "attribute_not_exists(unique_key)",
          })
        )
        inserted++
      } catch (error: unknown) {
        if ((error as { name?: string }).name === "ConditionalCheckFailedException") {
          skipped++
        } else {
          throw error
        }
      }
    }

    return { inserted, skipped }
  },

  async getStats(itemId?: string) {
    let items

    if (itemId) {
      const result = await dynamoDB.send(
        new QueryCommand({
          TableName: TABLES.REVIEWS,
          IndexName: "item_id-index",
          KeyConditionExpression: "item_id = :itemId",
          ExpressionAttributeValues: { ":itemId": itemId },
        })
      )
      items = result.Items || []
    } else {
      const result = await dynamoDB.send(
        new ScanCommand({ TableName: TABLES.REVIEWS })
      )
      items = result.Items || []
    }

    const total = items.length
    const positive = items.filter((r) => r.sentiment === "positive").length
    const negative = items.filter((r) => r.sentiment === "negative").length
    const neutral = items.filter((r) => r.sentiment === "neutral").length
    const avgRating = total > 0
      ? items.reduce((sum, r) => sum + (r.rating || 0), 0) / total
      : 0

    return {
      total,
      positive,
      negative,
      neutral,
      avgRating: Math.round(avgRating * 10) / 10,
    }
  },

  async bulkUpdateAnalysis(updates: Array<{
    id: string
    sentiment: "positive" | "negative" | "neutral"
    keywords: string[]
  }>) {
    let updated = 0

    for (const update of updates) {
      await dynamoDB.send(
        new UpdateCommand({
          TableName: TABLES.REVIEWS,
          Key: { id: update.id },
          UpdateExpression: "SET sentiment = :sentiment, keywords = :keywords",
          ExpressionAttributeValues: {
            ":sentiment": update.sentiment,
            ":keywords": update.keywords,
          },
        })
      )
      updated++
    }

    return updated
  },

  async getKeywordStats(itemIds?: string[]) {
    let items: Record<string, unknown>[] = []

    if (itemIds?.length) {
      for (const itemId of itemIds) {
        const result = await dynamoDB.send(
          new QueryCommand({
            TableName: TABLES.REVIEWS,
            IndexName: "item_id-index",
            KeyConditionExpression: "item_id = :itemId",
            ExpressionAttributeValues: { ":itemId": itemId },
          })
        )
        items.push(...(result.Items || []))
      }
    } else {
      const result = await dynamoDB.send(
        new ScanCommand({ TableName: TABLES.REVIEWS })
      )
      items = result.Items || []
    }

    const positiveKeywords: Record<string, number> = {}
    const negativeKeywords: Record<string, number> = {}

    items.forEach((review) => {
      const keywords = review.keywords as string[] || []
      const sentiment = review.sentiment as string

      keywords.forEach((kw) => {
        if (sentiment === "positive") {
          positiveKeywords[kw] = (positiveKeywords[kw] || 0) + 1
        } else if (sentiment === "negative") {
          negativeKeywords[kw] = (negativeKeywords[kw] || 0) + 1
        }
      })
    })

    const toSortedList = (obj: Record<string, number>) =>
      Object.entries(obj)
        .map(([word, count]) => ({ word, count }))
        .sort((a, b) => b.count - a.count)

    return {
      positive: toSortedList(positiveKeywords),
      negative: toSortedList(negativeKeywords),
    }
  },
}

// ============================================================
// Export
// ============================================================
export const dynamoDBLayer = {
  categories: dynamoCategories,
  items: dynamoItems,
  reviews: dynamoReviews,
}
```

---

# Part 3: 전역 변경 사항 체크리스트

## 3.1 변경해야 할 파일 목록

```
프로젝트 루트/
├── .env.local                    # 환경변수 변경
├── lib/
│   ├── supabase.ts              # → mongodb.ts 또는 dynamodb.ts로 대체
│   ├── local-db.ts              # 유지 (로컬 개발용)
│   ├── mongo-db.ts              # 신규 (MongoDB용)
│   ├── dynamo-db.ts             # 신규 (DynamoDB용)
│   ├── db.ts                    # 신규 (통합 인터페이스)
│   └── models/
│       └── index.ts             # 신규 (Mongoose 스키마)
├── app/api/
│   ├── categories/route.ts      # DB 레이어 import 변경
│   ├── items/route.ts           # DB 레이어 import 변경
│   ├── items/[id]/route.ts      # DB 레이어 import 변경
│   ├── items/[id]/crawl/route.ts # DB 레이어 import 변경
│   ├── reviews/route.ts         # DB 레이어 import 변경
│   └── analyze/route.ts         # DB 레이어 import 변경
└── types/
    └── database.ts              # 타입 정의 수정 (필요시)
```

## 3.2 통합 DB 인터페이스

### lib/db.ts (신규 생성 권장)

```typescript
/**
 * 통합 DB 인터페이스
 * 어떤 DB를 사용하든 동일한 API로 접근 가능
 */

import { localDB } from "./local-db"
// MongoDB 사용시:
// import { mongoDB } from "./mongo-db"
// DynamoDB 사용시:
// import { dynamoDBLayer } from "./dynamo-db"

// DB 타입 환경변수로 결정
const DB_TYPE = process.env.DB_TYPE || "local" // "local" | "mongodb" | "dynamodb" | "supabase"

function getDBLayer() {
  switch (DB_TYPE) {
    case "mongodb":
      // return mongoDB
      throw new Error("MongoDB not configured")
    case "dynamodb":
      // return dynamoDBLayer
      throw new Error("DynamoDB not configured")
    case "supabase":
      throw new Error("Use Supabase client directly")
    case "local":
    default:
      return localDB
  }
}

export const db = getDBLayer()

// 개별 export
export const categories = db.categories
export const items = db.items
export const reviews = db.reviews
```

## 3.3 API Route 변경 예시

### 변경 전 (Supabase 직접 사용)

```typescript
// app/api/categories/route.ts
import { createServerClient, useLocalDB } from "@/lib/supabase"
import { localDB } from "@/lib/local-db"

export async function GET() {
  if (useLocalDB) {
    const categories = await localDB.categories.getAll()
    return Response.json(categories)
  }

  const supabase = createServerClient()
  const { data, error } = await supabase.from("categories").select("*")
  // ...
}
```

### 변경 후 (통합 인터페이스)

```typescript
// app/api/categories/route.ts
import { db } from "@/lib/db"

export async function GET() {
  try {
    const categories = await db.categories.getAll()
    return Response.json(categories)
  } catch (error) {
    return Response.json({ error: "Failed to fetch" }, { status: 500 })
  }
}
```

## 3.4 DB별 주요 차이점

| 기능 | Supabase (PostgreSQL) | MongoDB | DynamoDB |
|------|----------------------|---------|----------|
| **ID 생성** | UUID (auto) | ObjectId (auto) | UUID (직접 생성) |
| **조인** | SQL JOIN | $lookup Aggregation | GSI + 별도 쿼리 |
| **트랜잭션** | 지원 | 지원 (4.0+) | 제한적 (TransactWrite) |
| **배치 쓰기** | bulk insert | insertMany | BatchWrite (25개 제한) |
| **인덱스** | CREATE INDEX | createIndex() | GSI 생성 |
| **중복 방지** | UNIQUE constraint | unique index | ConditionExpression |
| **RLS** | 내장 지원 | 직접 구현 | IAM 정책 |
| **실시간** | 내장 지원 | Change Streams | DynamoDB Streams |
| **비용** | Free tier 있음 | Free tier 있음 | On-demand/Provisioned |

## 3.5 마이그레이션 스크립트

### Supabase → MongoDB

```typescript
// scripts/migrate-supabase-to-mongo.ts
import { createClient } from "@supabase/supabase-js"
import { MongoClient } from "mongodb"

async function migrate() {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )

  const mongo = await MongoClient.connect(process.env.MONGODB_URI!)
  const db = mongo.db("cv-monitor")

  // Categories
  const { data: categories } = await supabase.from("categories").select("*")
  if (categories?.length) {
    await db.collection("categories").insertMany(categories)
    console.log(`✓ ${categories.length} categories migrated`)
  }

  // Items
  const { data: items } = await supabase.from("items").select("*")
  if (items?.length) {
    await db.collection("items").insertMany(items)
    console.log(`✓ ${items.length} items migrated`)
  }

  // Reviews (배치 처리)
  let offset = 0
  const batchSize = 1000
  while (true) {
    const { data: reviews } = await supabase
      .from("reviews")
      .select("*")
      .range(offset, offset + batchSize - 1)

    if (!reviews?.length) break

    await db.collection("reviews").insertMany(reviews)
    console.log(`✓ Reviews batch ${offset / batchSize + 1} migrated`)
    offset += batchSize
  }

  await mongo.close()
  console.log("Migration complete!")
}

migrate()
```

---

## 빠른 시작 체크리스트

### MongoDB 전환

- [ ] MongoDB Atlas 클러스터 생성
- [ ] `pnpm add mongodb mongoose`
- [ ] `.env.local`에 `MONGODB_URI` 설정
- [ ] `lib/mongodb.ts` 생성
- [ ] `lib/mongo-db.ts` 생성
- [ ] `lib/db.ts`에서 MongoDB 활성화
- [ ] API Routes import 변경
- [ ] 데이터 마이그레이션

### DynamoDB 전환

- [ ] AWS IAM 사용자 생성
- [ ] DynamoDB 테이블 4개 생성
- [ ] GSI 생성 (items, reviews)
- [ ] `pnpm add @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb uuid`
- [ ] `.env.local`에 AWS 자격 증명 설정
- [ ] `lib/dynamodb.ts` 생성
- [ ] `lib/dynamo-db.ts` 생성
- [ ] `lib/db.ts`에서 DynamoDB 활성화
- [ ] API Routes import 변경
- [ ] 데이터 마이그레이션

---

## 참고 링크

### MongoDB
- [MongoDB Atlas](https://www.mongodb.com/cloud/atlas)
- [Mongoose ODM](https://mongoosejs.com/docs/)
- [MongoDB Node.js Driver](https://mongodb.github.io/node-mongodb-native/)

### DynamoDB
- [AWS DynamoDB](https://aws.amazon.com/dynamodb/)
- [AWS SDK v3 for JavaScript](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/)
- [DynamoDB 베스트 프랙티스](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html)
